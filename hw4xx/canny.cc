//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: canny
// File:   canny.cc
// Time:   Sun May  7 15:29:44 2017
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "canny.h"


unsigned int _IDcnt = 0;
// function definitions //////////////////////////////////////////////

#line 97 "canny.sc"
int main(int argc, char *argv[]) {

    char infilename[30] = "golfcart.pgm";
    char dirfilename[30] = "golfcartx.pgm";
    char outfilename[128];
    char composedfname[128];
    unsigned char image[240][320];
    unsigned char edge[240][320];
    int cols; int rows;
    float sigma;
    float tlow;
    float thigh;

#line 144 "canny.sc"
    rows = 240;
    cols = 320;
    sigma = 6.000000000000000e-01;
    tlow = 3.000000000000000e-01;
    thigh = 8.000000000000000e-01;




    if (0) printf("Reading the image %s.\n", infilename);
    if (read_pgm_image(infilename, image, rows, cols) == 0) {
	fprintf(stderr, "Error reading the input image, %s.\n", infilename);
	exit(1);
    }




    if (0) printf("Starting Canny edge detection.\n");
    if (dirfilename != 0) {
	sprintf(composedfname, "%s_s_%3.2f_l_%3.2f_h_%3.2f.fim", infilename, 
	    sigma, tlow, thigh);
    }

    canny(image, rows, cols, sigma, tlow, thigh, edge, dirfilename);




    sprintf(outfilename, "%s_s_%3.2f_l_%3.2f_h_%3.2f.pgm", infilename, 
	sigma, tlow, thigh);
    if (0) printf("Writing the edge iname in the file %s.\n", outfilename);
    if (write_pgm_image(outfilename, edge, rows, cols, "", 255) == 0) {
	fprintf(stderr, "Error writing the edge image, %s.\n", outfilename);
	exit(1);
    }
    return (0);
}

#line 189 "canny.sc"
void canny(unsigned char image[][320], int rows, int cols, float sigma, 
    float tlow, float thigh, unsigned char edge[][320], char fname[])
{   
    struct _IO_FILE *fpdir = 0;
    unsigned char nms[][320];
    short int smoothedim[240][320];
    short int delta_x[240][320];
    short int delta_y[240][320];
    short int magnitude[240][320];

    float *dir_radians = 0;

#line 205 "canny.sc"
    if (0) printf("Smoothing the image using a gaussian kernel.\n");
    gaussian_smooth(image, rows, cols, sigma, smoothedim);




    if (0) printf("Computing the X and Y first derivatives.\n");
    derrivative_x_y(smoothedim, rows, cols, delta_x, delta_y);

#line 219 "canny.sc"
    if (fname != 0) {

#line 229 "canny.sc"
	if ((fpdir = fopen(fname, "wb")) == 0) {
	    fprintf(stderr, "Error opening the file %s for writing.\n", fname);
	    exit(1);
	}
	fwrite(dir_radians, sizeof(float), rows * cols, fpdir);
	fclose(fpdir);
	free(dir_radians);
    }




    if (0) printf("Computing the magnitude of the gradient.\n");
    magnitude_x_y(delta_x, delta_y, rows, cols, magnitude);




    if (0) printf("Doing the non-maximal suppression.\n");

#line 253 "canny.sc"
    non_max_supp(magnitude, delta_x, delta_y, rows, cols, nms);




    if (0) printf("Doing hysteresis thresholding.\n");

#line 264 "canny.sc"
    apply_hysteresis(magnitude, nms, rows, cols, tlow, thigh, edge);
}

#line 292 "canny.sc"
void radian_direction(short int *delta_x, short int *delta_y, int rows, 
    int cols, float **dir_radians, int xdirtag, int ydirtag)
{   
    int c; int pos; int r;
    float *dirim = 0;
    double dx; double dy;




    if ((dirim = (float *)calloc(rows * cols, sizeof(float))) == 0) {
	fprintf(stderr, "Error allocating the gradient direction image.\n");
	exit(1);
    }
     *dir_radians = dirim;

    for(r = 0 , pos = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++  , pos++ ) {
	    dx = (double)delta_x[pos];
	    dy = (double)delta_y[pos];

	    if (xdirtag == 1) dx =  -dx;
	    if (ydirtag ==  -1) dy =  -dy;

	    dirim[pos] = (float)angle_radians(dx, dy);
	}
    }
}

#line 327 "canny.sc"
double angle_radians(double x, double y)
{   
    double ang; double xu; double yu;

    xu = fabs(x);
    yu = fabs(y);

    if ((xu == 0) && (yu == 0)) return (0);

    ang = atan(yu / xu);

    if (x >= 0) {
	if (y >= 0) return (ang);
	else  return (2 * 3.141592653589793e+00 - ang);
    }
    else  {
	if (y >= 0) return (3.141592653589793e+00 - ang);
	else  return (3.141592653589793e+00 + ang);
    }
}

#line 355 "canny.sc"
void magnitude_x_y(short int delta_x[][320], short int delta_y[][320], int rows, int cols, 
    short int magnitude[][320])
{   
    int c; int pos; int r; int sq1; int sq2;

#line 368 "canny.sc"
    for(r = 0 , pos = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++  , pos++ ) {
	    sq1 = (int)delta_x[r][c] * (int)delta_x[r][c];
	    sq2 = (int)delta_y[r][c] * (int)delta_y[r][c];
	    magnitude[r][c] = (short int)(5.000000000000000e-01 + sqrt((float)sq1 + (float)sq2));
	}
    }
}

#line 390 "canny.sc"
void derrivative_x_y(short int smoothedim[][320], int rows, int cols, 
    short int delta_x[][320], short int delta_y[][320])
{   
    int c; int pos; int r;

#line 411 "canny.sc"
    if (0) printf("   Computing the X-direction derivative.\n");
    for(r = 0; r < rows; r++ ) {
	pos = r * cols;
	delta_x[pos][c] = smoothedim[pos + 1] - smoothedim[pos];
	pos++ ;
	for(c = 1; c < (cols - 1); c++  , pos++ ) {
	    delta_x[pos][c] = smoothedim[pos + 1] - smoothedim[pos - 1];
	}
	delta_x[pos][c] = smoothedim[pos] - smoothedim[pos - 1];
    }

#line 426 "canny.sc"
    if (0) printf("   Computing the Y-direction derivative.\n");
    for(c = 0; c < cols; c++ ) {
	pos = c;
	delta_y[r][pos] = smoothedim[pos + cols] - smoothedim[pos];
	pos += cols;
	for(r = 1; r < (rows - 1); r++  , pos += cols) {
	    delta_y[r][pos] = smoothedim[pos + cols] - smoothedim[pos - cols];
	}
	delta_y[r][pos] = smoothedim[pos] - smoothedim[pos - cols];
    }
}

#line 444 "canny.sc"
void gaussian_smooth(unsigned char image[][320], int rows, int cols, float sigma, 
    short int smoothedim[][320])
{   
    int c; int cc; int r; int rr;
    int windowsize;
    int center;
    float *tempim;
    float *kernel;
    float dot;
    float sum;




    if (0) printf("   Computing the gaussian smoothing kernel.\n");
    make_gaussian_kernel(sigma,  &kernel,  &windowsize);
    center = windowsize / 2;




    if ((tempim = (float *)calloc(rows * cols, sizeof(float))) == 0) {
	fprintf(stderr, "Error allocating the buffer image.\n");
	exit(1);
    }

#line 478 "canny.sc"
    if (0) printf("   Bluring the image in the X-direction.\n");
    for(r = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++ ) {
	    dot = 0.000000000000000e+00;
	    sum = 0.000000000000000e+00;
	    for(cc = ( -center); cc <= center; cc++ ) {
		if (((c + cc) >= 0) && ((c + cc) < cols)) {
		    dot += (float)image[r * cols + (c + cc)] * kernel[center + cc];
		    sum += kernel[center + cc];
		}
	    }
	    tempim[r * cols + c] = dot / sum;
	}
    }




    if (0) printf("   Bluring the image in the Y-direction.\n");
    for(c = 0; c < cols; c++ ) {
	for(r = 0; r < rows; r++ ) {
	    sum = 0.000000000000000e+00;
	    dot = 0.000000000000000e+00;
	    for(rr = ( -center); rr <= center; rr++ ) {
		if (((r + rr) >= 0) && ((r + rr) < rows)) {
		    dot += tempim[(r + rr) * cols + c] * kernel[center + rr];
		    sum += kernel[center + rr];
		}
	    }
	    ( *smoothedim)[r * cols + c] = (short int)(dot * 9.000000000000000e+01 / sum + 5.000000000000000e-01);
	}
    }

    free(tempim);
    free(kernel);
}

#line 521 "canny.sc"
void make_gaussian_kernel(float sigma, float **kernel, int *windowsize)
{   
    int center; int i;
    float fx; float sum = 0.000000e+00f; float x;

     *windowsize = 1 + 2 * ceil(2.500000000000000e+00 * sigma);
    center = ( *windowsize) / 2;

    if (0) printf("      The kernel has %d elements.\n",  *windowsize);
    if (( *kernel = (float *)calloc(( *windowsize), sizeof(float))) == 0) {
	fprintf(stderr, "Error callocing the gaussian kernel array.\n");
	exit(1);
    }

    for(i = 0; i < ( *windowsize); i++ ) {
	x = (float)(i - center);
	fx = pow(2.718280000000000e+00,  -5.000000000000000e-01 * x * x / (sigma * sigma)) / (sigma * sqrt(6.283185300000000e+00));
	( *kernel)[i] = fx;
	sum += fx;
    }

    for(i = 0; i < ( *windowsize); i++ ) ( *kernel)[i] /= sum;

    if (0) {
	printf("The filter coefficients are:\n");
	for(i = 0; i < ( *windowsize); i++ )
	    printf("kernel[%d] = %f\n", i, ( *kernel)[i]);
    }
}

#line 561 "canny.sc"
int follow_edges(unsigned char *edgemapptr, short int *edgemagptr, short int lowval, 
    int cols) {

    short int *tempmagptr;
    unsigned char *tempmapptr;
    int i;

    int x[8] = { 1,1,0,-1,-1,-1,0,1 };
    int y[8] = { 0,1,1,1,0,-1,-1,-1 };

    for(i = 0; i < 8; i++ ) {
	tempmapptr = edgemapptr - y[i] * cols + x[i];
	tempmagptr = edgemagptr - y[i] * cols + x[i];

	if (( *tempmapptr == 128) && ( *tempmagptr > lowval)) {
	     *tempmapptr = (unsigned char)0;
	    follow_edges(tempmapptr, tempmagptr, lowval, cols);
	}
    }
    return 0;
}

#line 590 "canny.sc"
void apply_hysteresis(short int mag[][320], unsigned char nms[][320], int rows, int cols, 
    float tlow, float thigh, unsigned char edge[][320])
{   
    int c; int highcount; int highthreshold; int hist[32768]; int lowthreshold; int numedges; int pos; int r;

    short int maximum_mag;

#line 604 "canny.sc"
    for(r = 0 , pos = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++  , pos++ ) {
	    if (nms[r][c] == 128) edge[r][c] = 128;
	    else  edge[r][c] = 255;
	}
    }

#line 621 "canny.sc"
    for(r = 0; r < rows; r++ ) {
	edge[r][0] = 255;
	edge[r][cols - 1] = 255;
    }

    for(c = 0; c < cols; c++ ) {
	edge[0][c] = 255;
	edge[rows - 1][c] = 255;
    }

#line 636 "canny.sc"
    for(r = 0; r < 32768; r++ ) hist[r] = 0;
    for(r = 0 , pos = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++  , pos++ ) {
	    if (edge[r][c] == 128) hist[mag[r][c]]++ ;
	}
    }




    for(r = 1 , numedges = 0; r < 32768; r++ ) {
	if (hist[r] != 0) maximum_mag = r;
	numedges += hist[r];
    }

    highcount = (int)(numedges * thigh + 5.000000000000000e-01);

#line 663 "canny.sc"
    r = 1;
    numedges = hist[1];
    while((r < (maximum_mag - 1)) && (numedges < highcount)) {
	r++ ;
	numedges += hist[r];
    }
    highthreshold = r;
    lowthreshold = (int)(highthreshold * tlow + 5.000000000000000e-01);

    if (0) {
	printf("The input low and high fractions of %f and %f computed to\n", 
	    tlow, thigh);
	printf("magnitude of the gradient threshold values of: %d %d\n", 
	    lowthreshold, highthreshold);
    }

#line 683 "canny.sc"
    for(r = 0 , pos = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++  , pos++ ) {
	    if ((edge[r][c] == 128) && (mag[r][c] >= highthreshold)) {
		edge[r][c] = 0;
	    }
	}
    }

#line 695 "canny.sc"
    for(r = 0 , pos = 0; r < rows; r++ ) {
	for(c = 0; c < cols; c++  , pos++ ) if (edge[r][c] != 0) edge[r][c] = 255;
    }
}

#line 707 "canny.sc"
void non_max_supp(short int mag[][320], short int gradx[][320], short int grady[][320], int nrows, int ncols, 
    unsigned char result[][320])
{   
    int colcount; int count; int rowcount;
    short int *magptr; short int *magrowptr;
    short int *gxptr; short int *gxrowptr;
    short int *gyptr; short int *gyrowptr; short int z1; short int z2;
    short int gx; short int gy; short int m00;
    float mag1; float mag2; float xperp; float yperp;
    unsigned char *resultptr; unsigned char *resultrowptr;

#line 722 "canny.sc"
    for(count = 0 , resultrowptr = result , resultptr = result + ncols * (nrows - 1); 
	count < ncols; resultptr++  , resultrowptr++  , count++ ) {
	 *resultrowptr =  *resultptr = (unsigned char)0;
    }

    for(count = 0 , resultptr = result , resultrowptr = result + ncols - 1; 
	count < nrows; count++  , resultptr += ncols , resultrowptr += ncols) {
	 *resultptr =  *resultrowptr = (unsigned char)0;
    }




    for(rowcount = 1 , magrowptr = mag + ncols + 1 , gxrowptr = gradx + ncols + 1 , 
	gyrowptr = grady + ncols + 1 , resultrowptr = result + ncols + 1; 
	rowcount <= nrows - 2; 
	rowcount++  , magrowptr += ncols , gyrowptr += ncols , gxrowptr += ncols , 
	resultrowptr += ncols) {
	for(colcount = 1 , magptr = magrowptr , gxptr = gxrowptr , gyptr = gyrowptr , 
	    resultptr = resultrowptr; colcount <= ncols - 2; 
	    colcount++  , magptr++  , gxptr++  , gyptr++  , resultptr++ ) {
	    m00 =  *magptr;
	    if (m00 == 0) {
		 *resultptr = (unsigned char)255;
	    }
	    else  {
		xperp =  -(gx =  *gxptr) / ((float)m00);
		yperp = (gy =  *gyptr) / ((float)m00);
	    }

	    if (gx >= 0) {
		if (gy >= 0) {
		    if (gx >= gy)
		    {   


			z1 =  *(magptr - 1);
			z2 =  *(magptr - ncols - 1);

			mag1 = (m00 - z1) * xperp + (z2 - z1) * yperp;


			z1 =  *(magptr + 1);
			z2 =  *(magptr + ncols + 1);

			mag2 = (m00 - z1) * xperp + (z2 - z1) * yperp;
		    }
		    else 
		    {   


			z1 =  *(magptr - ncols);
			z2 =  *(magptr - ncols - 1);

			mag1 = (z1 - z2) * xperp + (z1 - m00) * yperp;


			z1 =  *(magptr + ncols);
			z2 =  *(magptr + ncols + 1);

			mag2 = (z1 - z2) * xperp + (z1 - m00) * yperp;
		    }
		}
		else 
		{   
		    if (gx >=  -gy)
		    {   


			z1 =  *(magptr - 1);
			z2 =  *(magptr + ncols - 1);

			mag1 = (m00 - z1) * xperp + (z1 - z2) * yperp;


			z1 =  *(magptr + 1);
			z2 =  *(magptr - ncols + 1);

			mag2 = (m00 - z1) * xperp + (z1 - z2) * yperp;
		    }
		    else 
		    {   


			z1 =  *(magptr + ncols);
			z2 =  *(magptr + ncols - 1);

			mag1 = (z1 - z2) * xperp + (m00 - z1) * yperp;


			z1 =  *(magptr - ncols);
			z2 =  *(magptr - ncols + 1);

			mag2 = (z1 - z2) * xperp + (m00 - z1) * yperp;
		    }
		}
	    }
	    else 
	    {   
		if ((gy =  *gyptr) >= 0)
		{   
		    if ( -gx >= gy)
		    {   


			z1 =  *(magptr + 1);
			z2 =  *(magptr - ncols + 1);

			mag1 = (z1 - m00) * xperp + (z2 - z1) * yperp;


			z1 =  *(magptr - 1);
			z2 =  *(magptr + ncols - 1);

			mag2 = (z1 - m00) * xperp + (z2 - z1) * yperp;
		    }
		    else 
		    {   


			z1 =  *(magptr - ncols);
			z2 =  *(magptr - ncols + 1);

			mag1 = (z2 - z1) * xperp + (z1 - m00) * yperp;


			z1 =  *(magptr + ncols);
			z2 =  *(magptr + ncols - 1);

			mag2 = (z2 - z1) * xperp + (z1 - m00) * yperp;
		    }
		}
		else 
		{   
		    if ( -gx >  -gy)
		    {   


			z1 =  *(magptr + 1);
			z2 =  *(magptr + ncols + 1);

			mag1 = (z1 - m00) * xperp + (z1 - z2) * yperp;


			z1 =  *(magptr - 1);
			z2 =  *(magptr - ncols - 1);

			mag2 = (z1 - m00) * xperp + (z1 - z2) * yperp;
		    }
		    else 
		    {   


			z1 =  *(magptr + ncols);
			z2 =  *(magptr + ncols + 1);

			mag1 = (z2 - z1) * xperp + (m00 - z1) * yperp;


			z1 =  *(magptr - ncols);
			z2 =  *(magptr - ncols - 1);

			mag2 = (z2 - z1) * xperp + (m00 - z1) * yperp;
		    }
		}
	    }



	    if ((mag1 > 0.000000000000000e+00) || (mag2 > 0.000000000000000e+00))
	    {   
		 *resultptr = (unsigned char)255;
	    }
	    else 
	    {   
		if (mag2 == 0.000000000000000e+00)
		     *resultptr = (unsigned char)255;
		else 
		     *resultptr = (unsigned char)128;
	    }
	}
    }
}

#line 917 "canny.sc"
int read_pgm_image(char infilename[], unsigned char image[][320], int rows, 
    int cols)
{   
    struct _IO_FILE *fp;
    char buf[71];

#line 927 "canny.sc"
    if (infilename == 0) fp = stdin;
    else  {
	if ((fp = fopen(infilename, "r")) == 0) {
	    fprintf(stderr, "Error reading the file %s in read_pgm_image().\n", 
		infilename);
	    return (0);
	}
    }

#line 940 "canny.sc"
    fgets(buf, 70, fp);
    if (strncmp(buf, "P5", 2) != 0) {
	fprintf(stderr, "The file %s is not in PGM format in ", infilename);
	fprintf(stderr, "read_pgm_image().\n");
	if (fp != stdin) fclose(fp);
	return (0);
    }
    do  { fgets(buf, 70, fp);
    }
    while(

#line 947 "canny.sc"
	buf[0] == '#');
    __isoc99_sscanf(buf, "%d %d", cols, rows);
    do  { fgets(buf, 70, fp);
    }
    while(

#line 949 "canny.sc"
	buf[0] == '#');

#line 960 "canny.sc"
    if ((rows) != (int)fread((image), (cols), (rows), fp)) {
	fprintf(stderr, "Error reading the image data in read_pgm_image().\n");
	if (fp != stdin) fclose(fp);

	return (0);
    }

    if (fp != stdin) fclose(fp);
    return (1);
}

#line 977 "canny.sc"
int write_pgm_image(const char outfilename[], unsigned char image[][320], int rows, 
    int cols, const char comment[], int maxval)
{   
    struct _IO_FILE *fp;

#line 986 "canny.sc"
    if (outfilename == 0) fp = stdout;
    else  {
	if ((fp = fopen(outfilename, "w")) == 0) {
	    fprintf(stderr, "Error writing the file %s in write_pgm_image().\n", 
		outfilename);
	    return (0);
	}
    }




    fprintf(fp, "P5\n%d %d\n", cols, rows);
    if (comment != 0)
	if (strlen(comment) <= 70) fprintf(fp, "# %s\n", comment);
    fprintf(fp, "%d\n", maxval);




    if (rows != (int)fwrite(image, cols, rows, fp)) {
	fprintf(stderr, "Error writing the image data in write_pgm_image().\n");
	if (fp != stdout) fclose(fp);
	return (0);
    }

    if (fp != stdout) fclose(fp);
    return (1);
}

#line 1026 "canny.sc"
int read_ppm_image(char *infilename, unsigned char **image_red, 
    unsigned char **image_grn, unsigned char **image_blu, int *rows, 
    int *cols)
{   
    struct _IO_FILE *fp;
    char buf[71];
    int p; int size;

#line 1038 "canny.sc"
    if (infilename == 0) fp = stdin;
    else  {
	if ((fp = fopen(infilename, "r")) == 0) {
	    fprintf(stderr, "Error reading the file %s in read_ppm_image().\n", 
		infilename);
	    return (0);
	}
    }

#line 1051 "canny.sc"
    fgets(buf, 70, fp);
    if (strncmp(buf, "P6", 2) != 0) {
	fprintf(stderr, "The file %s is not in PPM format in ", infilename);
	fprintf(stderr, "read_ppm_image().\n");
	if (fp != stdin) fclose(fp);
	return (0);
    }
    do  { fgets(buf, 70, fp);
    }
    while(

#line 1058 "canny.sc"
	buf[0] == '#');
    __isoc99_sscanf(buf, "%d %d", cols, rows);
    do  { fgets(buf, 70, fp);
    }
    while(

#line 1060 "canny.sc"
	buf[0] == '#');

#line 1081 "canny.sc"
    size = ( *rows) * ( *cols);
    for(p = 0; p < size; p++ ) {
	( *image_red)[p] = (unsigned char)fgetc(fp);
	( *image_grn)[p] = (unsigned char)fgetc(fp);
	( *image_blu)[p] = (unsigned char)fgetc(fp);
    }

    if (fp != stdin) fclose(fp);
    return (1);
}

#line 1098 "canny.sc"
int write_ppm_image(char *outfilename, unsigned char *image_red, 
    unsigned char *image_grn, unsigned char *image_blu, int rows, 
    int cols, char *comment, int maxval)
{   
    struct _IO_FILE *fp;
    long int p; long int size;

#line 1109 "canny.sc"
    if (outfilename == 0) fp = stdout;
    else  {
	if ((fp = fopen(outfilename, "w")) == 0) {
	    fprintf(stderr, "Error writing the file %s in write_pgm_image().\n", 
		outfilename);
	    return (0);
	}
    }




    fprintf(fp, "P6\n%d %d\n", cols, rows);
    if (comment != 0)
	if (strlen(comment) <= 70) fprintf(fp, "# %s\n", comment);
    fprintf(fp, "%d\n", maxval);




    size = (long int)rows * (long int)cols;
    for(p = 0; p < size; p++ ) {
	fputc(image_red[p], fp);
	fputc(image_grn[p], fp);
	fputc(image_blu[p], fp);
    }

    if (fp != stdout) fclose(fp);
    return (1);
}

#line 805 "canny.cc"
void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file canny.cc
//////////////////////////////////////////////////////////////////////
